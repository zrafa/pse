Chapter 1. Introduction

Introducción


I think there is a world market for maybe five computers.
—Thomas Watson, Chairman of IBM, 1943
There is no reason anyone would want a computer in their home.
—Ken Olson, President of Digital Equipment Corporation, 1977

One of the more surprising developments of the last few decades has been the ascendance of computers
to a position of prevalence in human affairs. Today there are more computers in our homes and offices
than there are people who live and work in them. Yet many of these computers are not recognized as
such by their users. In this chapter, we'll explain what embedded systems are and where they are found.
We will also introduce the subject of embedded programming and discuss what makes it a unique form
of software programming. We'll explain why we have selected C as the language for this book and
describe the hardware used in the examples.



1.1. What Is an Embedded System?

Qué es un sistema embebido?

An embedded system is a combination of computer hardware and software—and perhaps additional
parts, either mechanical or electronic—designed to perform a dedicated function. A good example is the
microwave oven. Almost every household has one, and tens of millions of them are used every day, but
very few people realize that a computer processor and software are involved in the preparation of their
lunch or dinner.

Un sistema embebido es una combinación de hardware y software (una o más computadoras) y probablemente partes adicionales,
electrónicas, mecánicas y tal vez químicas, diseńadas para realizar una única función.
Un buen ejemplo es el horno microhondas, un smartphone o el sistema de inyección electrónica de un auto.
Casi todo sistema digital de un hogar contiene uno, y billones de estos sistemas en están en uso 
cada día, pero pocas personas se dan cuenta que un procesador de computadora y software están
involucrados en el control del sistema (y son quienes realmente están cocinando).



The design of an embedded system to perform a dedicated function is in direct contrast to that of the
personal computer. It too is comprised of computer hardware and software and mechanical components
(disk drives, for example). However, a personal computer is not designed to perform a specific function.
Rather, it is able to do many different things. Many people use the term general-purpose computer to
make this distinction clear. As shipped, a general-purpose computer is a blank slate; the manufacturer
does not know what the customer will do with it. One customer may use it for a network file server,
another may use it exclusively for playing games, and a third may use it to write the next great American
novel.


El diseńo de un sistema embebido para realizar una función específica es diferente al de una
computadora personal, aún si el hardware es similar. Una computadora personal no está diseńada
para realizar diferentes tareas, y muchas personas utilizan el nombre de computadora de propósito-general
para que la distinción sea clara. Una vez fabricada, una PC tiene un destino indefinido; 
ya que el fabricante no conoce qué hará el cliente con la máquina. Un consumidor podría utilizar
la PC para instalar un servidor de red, otro podría usarla exclusivamente para jugar videojuegos,
y un tercero podría utilizar su computadora para escribir su próxima gran Novela de ciencia ficción.



Frequently, an embedded system is a component within some larger system. For example, modern cars
and trucks contain many embedded systems. One embedded system controls the antilock brakes, another
monitors and controls the vehicle's emissions, and a third displays information on the dashboard. Some
luxury car manufacturers have even touted the number of processors (often more than 60, including one
in each headlight) in advertisements. In most cases, automotive embedded systems are connected by a
communications network.

Frecuentemente, un sistema embebido es un componente de un sistema mayor. Por ejemplo, 
los autos y camiones modernos contienen decenas de sistemas embebidos. Un sistema controla 
el sistema de frenos antibloquenates, otro monitorea y controla la emisión del vehículo, 
y un tercero muestra en pantalla información general del auto al conductor.  Algunos fabricantes de
autos de lujo incorporan en sus publicidades la cantidad numerosa de procesadores que contiene
el auto. Para este caso particular, la mayoría de los sistemas embebidos en un auto
están interconectados a través de una red de comunicaciones.



It is important to point out that a general-purpose computer interfaces to numerous embedded systems.
For example, a typical computer has a keyboard and mouse, each of which is an embedded system.
These peripherals each contain a processor and software and is designed to perform a specific function.
Another example is a modem, which is designed to send and receive digital data over an analog
telephone line; that's all it does. And the specific function of other peripherals can each be summarized
in a single sentence as well.

Un detalle que vale la pena mencionar es que las PC se comunican (interfacing) con 
muchos sistemas embebidos. Por ejemplo, una computadora personal tiene un teclado y un mouse,
los cuales son sistemas embebidos. Estos periféricos contienen un microcontrolador (el cual
a su vez contiene una CPU) que controlan el periférico y se comunican con la computadora.
Su software (usualmente llamado firmware) fue desarrollado para realizar una función.
Otro ejemplo es un disco pen drive USB (USB disk drive), el cual contiene una memoria NAND flash,
un oscilador, y un microcontrolador que controla la memoria flash y se comunica con la PC
via USB. Los demás periféricos de la PC (impresoras, pantallas, cámaras, etc) tambien
contienen un sistema embebido, y su función específica puede ser expresada utilizando
una única sentencia.




The existence of the processor and software in an embedded system may be unnoticed by a user of the
device. Such is the case for a microwave oven, MP3 player, or alarm clock. In some cases, it would even
be possible to build a functionally equivalent device that does not contain the processor and software.
This could be done by replacing the processor-software combination with a custom integrated circuit
(IC) that performs the same functions in hardware. However, the processor and software combination
typically offers more flexibility than a hardwired design. It is generally much easier, cheaper, and less
power intensive to use a processor and software in an embedded system.


La existencia de un procesador y de software en un sismtea embebidos suele estar presente sin
ser notado por el usuario del dispositivo. Tal es el caso de un parlante bluetooht, un horno microhondas,
o un receptor de TV satelital, por citar algunos ejemplos. En muchos casos es aún posible construir
un dispositivo con una funcionalidad equivalente, que no contiene un procesador y software. 
Esto podría llegar a ser desarrollado reemplazando el procesador y su software con un circuito integrado
(IC) que realiza la misma funcionalidad en hardware. De cualquier manera, la combinación
procesador-software tipicamente ofrece mas flexibilidad que un diseńo exclusivo en hardware. 
Utilizar un procesador y software en un sistema embebidos es usualmente mucho mas fácil, mas barato y 
consume menos energía.

1.1.1. History and Future

Hisstoria y Futuro

Given the definition of embedded systems presented earlier in this chapter, the first such systems could
not possibly have appeared before 1971. That was the year Intel introduced the world's first single-chip
microprocessor. This chip, the 4004, was designed for use in a line of business calculators produced by
the Japanese company Busicom. In 1969, Busicom asked Intel to design a set of custom integrated
circuits, one for each of its new calculator models. The 4004 was Intel's response. Rather than design
custom hardware for each calculator, Intel proposed a general-purpose circuit that could be used
throughout the entire line of calculators. This general-purpose processor was designed to read and
execute a set of instructions—software—stored in an external memory chip. Intel's idea was that the
software would give each calculator its unique set of features and that this design style would drive
demand for its core business in memory chips.

El primer sistema embebido no apareció hasta después de 1971, si nos guiamos por la
la definición presentada anteriormente En ese ańo Intel introdujo el primer microprocesador en el mundo
que fue plasmado en un chip individual. Ese chip, el 4004, fue diseńado para ser utilizado 
en una familia de calculadoras diferentes, producidas por una companía Japonesa llamada Busicom.
En 1969, Busicom le preguntó a Intel si podría diseńar un conjunto de circuitos integrados,
uno para cada una de sus calculadoras. El 4004 fue la respuesta de Intel. En vez de diseñar
hardware específico para cada calculadora, Intel propuso un circuito de propósito-general
que podría ser utilizado a través de toda la línea de calculadoras. Este procesador de propósito-general
fue diseñado para leer y ejecutar un conjunto de instrucciones almacenadas en un chip de memoria
externo al procesador. La idea de Intel fue que el software le daría a cada calculadora
un conjunto único de características, y que el este estilo de diseño ayudaría al corazón de su 
negocio que fueron los chips de memoria.


The microprocessor was an overnight success, and its use increased steadily over the next decade. Early
embedded applications included unmanned space probes, computerized traffic lights, and aircraft flight
control systems. In the 1980s and 1990s, embedded systems quietly rode the waves of the
microcomputer age and brought microprocessors into every part of our personal and professional lives.
Most of the electronic devices in our kitchens (bread machines, food processors, and microwave ovens),
living rooms (televisions, stereos, and remote controls), and workplaces (fax machines, pagers, laser
printers, cash registers, and credit card readers) are embedded systems; over 6 billion new
microprocessors are used each year. Less than 2 percent (or about 100 million per year) of these
microprocessors are used in general-purpose computers.

El microprocesador fue un éxito, y su utilización se incrementó continuamente en la siguiente
década. Las primeras aplicaciones embebidas incluyeron sondas espaciales no tripuladas, 
semáforos computarizados y sistemas de control de vuelo de los aviones.
En las décadas de 1980 y 1990, los sistemas embebidos estuvieron presentes silenciosamente
en la era de las microcomputadoras, y luego hicieron que los microprocesadores
pasaran a ser parte de nuestras vidas personales y profesionales.
La mayoría de los dispositivos electrónicos en nuestras cocinas (las máquinas para fabricar pan, la procesadora,
el hornos de microondas), en el living (televisores, equipos de música, controles remotos) y 
en nuestros trabajos (impresoras laser, tarjetas RFID para ingreso, máquinas expendedoras de café,
cajas registradoras, lectores de tarjetas de crédito) son sistemas embebidos.
En el 2006 se utilizaron más de 6 mil millones de microprocesadores nuevos. 
De ese número, menos del 2 por ciento (o aproximadamente 100 millones) de estos microprocesadores 
se utilizaron en computadoras personales, el resto fue destinado a sistemas embebidos.

It seems inevitable that the number of embedded systems will continue to increase rapidly. Already there
are promising new embedded devices that have enormous market potential: light switches and
thermostats that are networked together and can be controlled wirelessly by a central computer,
intelligent air-bag systems that don't inflate when children or small adults are present, medical
monitoring devices that can notify a doctor if a patient's physiological conditions are at critical levels,
and dashboard navigation systems that inform you of the best route to your destination under current
traffic conditions. Clearly, individuals who possess the skills and the desire to design the next generation
of embedded systems will be in demand for quite some time.

Es inevitable que el número de sistemas embebidos continúe aumentando año tras año,
ya que nuevos dispositivos se incorporan día a día a nuestras vidas: interruptores de luz y termostatos 
que están conectados en red y pueden ser controlados de forma inalámbrica por nuestros smartphones,
sistemas inteligentes de airbags que no se activan cuando hay niños o adultos pequeños, 
dispositivos médicos de monitoreo que pueden notificar a un médico si las condiciones 
fisiológicas de un paciente se encuentran en niveles críticos, marcapasos de corazón que deben
activarse con restricciones de tiempo muy rigurosas, y sistemas de navegación 
en el tablero que le informan sobre la mejor ruta hacia su destino en las condiciones de 
tráfico actuales. 
Claramente, la demanda por ingenieros que poseen las habilidades y las ganas de diseñar 
la próxima generación de sistemas embebidos está vigente, y lo estará por mucho tiempo.


1.1.2. Real-Time Systems

Sistemas de Tiempor Real 

One subclass of embedded systems deserves an introduction at this point. A real-time system has timing
constraints. The function of a real-time system is thus partly specified in terms of its ability to make
certain calculations or decisions in a timely manner. These important calculations or activities have
deadlines for completion.

Una subclase de sistemas embebidos que merece una introducción son los sistemas de tiempo real,
los cuales son sistemas con restricciones de tiempo de repuesta.
La función de un sistema en tiempo real se define, en parte, por su capacidad para hacer
ciertos cálculos o decisiones de manera oportuna. Estos cálculos o actividades 
tienen plazos de finalización específicos.

The crucial distinction among real-time systems lies in what happens if a deadline is missed. For
example, if the real-time system is part of an airplane's flight control system, the lives of the passengers
and crew may be endangered by a single missed deadline. However, if instead the system is involved in
satellite communication, the damage could be limited to a single corrupt data packet (which may or may
not have catastrophic consequences depending on the application and error recovery scheme). The more
severe the consequences, the more likely it will be said that the deadline is "hard" and thus, that the
system is a hard real-time system. Real-time systems at the other end of this continuum are said to have
"soft" deadlines—a soft real-time system. Figure 1-1 shows some examples of hard and soft real-time
systems.
Figure 1-1. A range of example real-time systems

Existen al menos en la literatura dos categorías de sistemas de tiempo real.
La distinción crucial entre estos radica en lo que sucede si el sistema respondió o no antes
del tiempo definido estricto de respuesta.
Por ejemplo, si el sistema de tiempo real es parte del sistema de control de vuelo de un avión, 
la vida de los pasajeros y la tripulación puede estar en peligro si el sistema no logra
producir la salida antes del tiempo límite (missed deadline).

Si en cambio el sistema está involucrado en la comunicación satelital, el daño podría 
limitarse a la pérdida de un solo paquete de datos (que puede tener o no consecuencias 
catastróficas dependiendo de la aplicación y el esquema de recuperación de errores). 
Si las consecuencias son graves, los sistemas de tiempo real se especifican (y se categorizan)
como sistemas de tiempo real duro (hard real time systems). En esta categoría, si el sistema falla una única vez
en responder antes del tiempo límite (y aún si lo hizo bien por billones de veces) se dice que el 
sistema falló, y no es de tiempo real duro.
En el otro extremo se define la cateoría de los sistemas de tiempo real blandos (soft real time systems).
En esta categoría, los tiempos límites de respuesta existen en la especificación, pero para
ciertos eventos está permitido no cumplir el plazo de tiempo para una respuesta, y por lo tanto
el sistema no falló si eso sucede.
La Figura 1-1 muestra algunos ejemplos de sistemas de tiempo real duros y blandos.





Real-time system design is not simply about speed. Deadlines for real-time systems vary; one deadline
might be in a millisecond, while another is an hour away. The main concern for a real-time system is
that there is a guarantee that the hard deadlines of the system are always met. In order to accomplish this
the system must be predictable.


En el diseño de un sistema de tiempo real no se trata simplemente de la
velocidad de respuesta. Los plazos para los sistemas en tiempo real varían; 
un tiempo límite puede estar en el orden de los milisegundos, mientras que otro 
a una hora de distancia. El principal objetivo de un sistema en tiempo real es
que garantice que siempre se cumplen los plazos estrictos del sistema. 
Para lograr esto, el sistema debe ser predecible.

The architecture of the embedded software, and its interaction with the system hardware, play a key role
in ensuring that real-time systems meet their deadlines. Key software design issues include whether
polling is sufficient or interrupts should be used, and what priorities should be assigned to the various
tasks and interrupts. Additional forethought must go into understanding the worst-case performance
requirements of the specific system activities.

La arquitectura del software embebido y su interacción con el hardware juegan 
un papel clave para garantizar que los sistemas de tiempo real cumplan con sus plazos. 
En el diseño del software se debe decidir si el acceso a los dispositivos con E/S programada
(polling) es suficiente, o si se debe utilizar interrupciones, y qué prioridades 
se deben asignar a las diversas tareas y a las rutinas de atención de interrupciones. 
Un análisis adicional debe hacerse: entender los requerimientos de rendimiento del peor caso
(o de varios si los hubiese).

All of the topics and examples presented in this book are applicable to the designers of real-time
systems. The designer of a real-time system must be more diligent in his work. He must guarantee
reliable operation of the software and hardware under all possible conditions. And, to the degree that
human lives depend upon the system's proper execution, this guarantee must be backed by engineering
calculations and descriptive paperwork.

El diseñador de un sistema en tiempo real (o su equipo si el sistema es complejo) debe ser
muy eficas en su labor (debe prestar mayor atención y cuidado al diseño de un sistema
de tiempo real que de uno que no lo es); 
ya que debe 
garantizar el funcionamiento confiable del software y hardware en todas 
las condiciones posibles. Y, en la medida en que las vidas de las personas dependan 
de la ejecución adecuada del sistema, esta garantía debe estar respaldada por 
cálculos de ingeniería y documentación descriptiva completa.


1.2. Variations on a Theme

Caracterísitcas del Hardware

Unlike software designed for general-purpose computers, embedded software cannot usually be run on
other embedded systems without significant modification. This is mainly because of the incredible
variety of hardware in use in embedded systems. The hardware in each embedded system is tailored
specifically to the application, in order to keep system costs low. As a result, unnecessary circuitry is
eliminated and hardware resources are shared wherever possible.
In this section, you will learn which hardware features are common across all embedded systems and
why there is so much variation with respect to just about everything else. Later in the book, we will look
at some techniques that can be used to minimize the impact of software changes so they are not needed
throughout all layers of the software.


A diferencia del software diseñado para PC, el software embebido no puede ser ejecutado
en otros sistemas embebidos sin realizar una modificación considerable. Esto se debe 
principalmente a la increíble variedad de hardware que se utilza.
El hardware de cada sistema embebido está diseñado específicamente para la aplicación, 
a fin de mantener los costos del sistema lo más bajo posible. Como resultado, 
se elimina toda la circuitería innecesaria, y los recursos de hardware se 
aprovechan al máximo en la medida de lo posible.
En esta sección, se detallan las características de hardware que son comunes 
a todos los sistemas embebidos y por qué hay tanta variedad con respecto a casi 
todo lo demás. Existen técnicas de desarrollo inicial para minimizar el impacto de 
los cambios de software si el hardware llega a cambiar, de modo que no deberían
hacerse modificaciones en todas las capas del software.

1.2.1. Common System Components

Componentes del Sistema Comunes

By definition, all embedded systems contain a processor and software, but what other features do they
have in common? Certainly, in order to have software, there must be a place to store the executable code
and temporary storage for runtime data manipulation. These take the form of read-only memory (ROM)
and random access memory (RAM), respectively; most embedded systems have some of each. If only a
small amount of memory is required, it might be contained within the same chip as the processor.
Otherwise, one or both types of memory reside in external memory chips.
All embedded systems also contain some type of inputs and outputs. For example, in a microwave oven,
the inputs are the buttons on the front panel and a temperature probe, and the outputs are the human-
readable display and the microwave radiation. The outputs of the embedded system are almost always a
function of its inputs and several other factors (elapsed time, current temperature, etc.). The inputs to the
system usually take the form of sensors and probes, communication signals, or control knobs and
buttons. The outputs are typically displays, communication signals, or changes to the physical world.
See Figure 1-2 for a general example of an embedded system.

Por definición, todos los sistemas embebidos contienen un procesador y software, 
pero ¿qué otras características tienen en común?. En realidad, para poder tener software, 
se debe contar con algún lugar donde almacenar el código ejecutable y tambien
memoria temporal para las variables y el estado del programa en tiempo de ejecución. 
Por lo que casi todos los sistemas embebidos incluyen una memoria de solo lectura (ROM) 
para almacenar el programa, y una memoria de acceso aleatorio (RAM), para la vida
de las variables en tiempo de ejecución. Si solo se requiere una pequeña cantidad 
de memoria entonces usualmente ambas memorias están contenidas dentro del mismo chip que el procesador.
De lo contrario, uno o ambos tipos de memoria residen en chips de memoria externos.

Todos los sistemas embebidos también presentan entradas y salidas. Por ejemplo, 
en nuestro ejemplo de horno microondas, las entradas son los botones en el panel 
frontal y una sonda de temperatura, y las salidas son la pantalla (DISPLAY) 
la radiación de microondas, y su control. Las salidas de un sistema embebido es 
casi siempre una función de sus entradas plus otros factores (tiempo transcurrido, 
temperatura actual, etc.). La teoría de control (al menos en su forma
más común utilizada, llamada PID control)
se estudia en varias ramas de ingeniería, y se utiliza en el diseño de las 
funciones de salida de un sistema embebido. Las entradas al sistema generalmente toman 
la forma de sensores y sondas, señales de comunicación o perillas, y botones de control. 
Las salidas son típicamente pantallas, señales de comunicación o cambios en el mundo físico.

Consulte la Figura 1-2 para ver un ejemplo general de un sistema integrado.


Figure 1-2. A generic embedded system


With the exception of these few common features, the rest of the embedded hardware is usually unique
and, therefore, requires unique software. This variation is the result of many competing design criteria.
The software for the generic embedded system shown in Figure 1-2 varies depending on the
functionality needed. The hardware is the blank canvas, and the software is the paint that we add in
order to make the picture come to life. Figure 1-3 gives just a couple of possible high-level diagrams
that could be implemented on such a generic embedded system.

Con la excepción de estas pocas características comunes, el resto del hardware en un sistema
embebido es generalmente único y, por lo tanto, requiere un software único. 
Esta variación es el resultado de muchos criterios de diseño competitivos de los fabricantes.
El software para un sistema embebido genérico que se muestra en la Figura 1-2 
varía según la funcionalidad necesaria. El hardware es el recuadro en blanco, 
y el software es la pintura agregada para que la imagen cobre vida. 
La Figura 1-3 proporciona un par de diagramas de alto nivel 
posibles, que podrían implementarse en un sistema embebido genérico.

Figure 1-3. (a) Basic embedded software diagram and (b) a more complex embedded software
diagram

Both the basic embedded software diagram in Figure 1-3(a) and the more complex embedded software
diagram in Figure 1-3(b) contain very similar blocks. The hardware block is common in both diagrams.
The device drivers are embedded software modules that contain the functionality to operate the
individual hardware devices. The reason for the device driver software is to remove the need for the
application to know how to control each piece of hardware. Each individual device driver would
typically need to know only how to control its hardware device. For instance, for a microwave oven,
separate device drivers control the keypad, display, temperature probe, and radiation control.
If more functionality is required, it is sometimes necessary to include additional layers in the embedded
software to assist with this added functionality. In this example, the complex diagram includes a real-
time operating system (RTOS) and a networking stack. The RTOS can help the programmer separate the
application's functionality into distinct tasks for better organization of the application software and a
more responsive system. We will investigate the use of an RTOS later in this book. The network stack
also adds to the functionality of the basic embedded system; a microwave oven might use it to pop up a
message on your desktop computer when your lunch is ready.

Tanto el diagrama de software embebido básico en la Figura 1-3 (a) como el diagrama de software más complejo 
en la Figura 1-3 (b) contienen bloques muy similares. El bloque de hardware es común en ambos diagramas.
Los controladores de dispositivo (drivers) son módulos de software que contienen la funcionalidad 
para operar (controlar) los dispositivos de hardware (periféricos). Estos controladores
eliminan la necesidad de que la aplicación sepa cómo controlar cada pieza de hardware, además permiten su rehuso. 
Cada controlador individual de dispositivo normalmente necesitaría saber solo cómo controlar su dispositivo de hardware y no varios. 
Por ejemplo, para un horno microondas, tendríamos que desarrollar o incorporar al menos cuatro drivers distintos: 
los controladores del teclado, la pantalla, la sonda de temperatura y el control de radiación.
Si el sistema requiere de más funcionalidades a veces es necesario incluir capas 
de software adicionales para ayudar con cada funcionalidad adicional. 
En este ejemplo, el diagrama complejo incluye un sistema operativo en tiempo real (RTOS) 
y una pila de red. El RTOS usualmente no es un sistema operativo completo, sino que más
bien son módulos de software que ayudan al programador a separar la funcionalidad 
de la aplicación en tareas diferentes para una mejor organización del software,
y que el sistema sea más receptivo. 
La pila de red también se suma como funcionalidad extra al sistema básico; 
un horno de microondas podría usar la red para que aparezca un mensaje 
en su computadora de escritorio cuando su almuerzo esté listo.


The responsibilities of the application software layer is the same in both the basic and the complex
embedded software diagrams. In a microwave oven, the application processes the different inputs and
controls the outputs based on what the user commands it to do.
You'll notice that the software in Figure 1-3 is represented by discrete blocks stacked on top of one
another with fixed borders. This is done deliberately, to indicate the separation of the different software
functional layers that make up the complete embedded software system. Later, we will break down these
blocks further to show you how you can keep your embedded software clean, easy to read, and portable.
Keeping these software layers distinct, with well-defined methods that neighboring layers can use to
communicate, helps you write good embedded software.


Las responsabilidades de la capa de software de aplicación son las mismas 
en los diagramas de software integrados básicos y complejos. 
En un horno microondas, la aplicación procesa las diferentes entradas 
y controla las salidas en función de lo que el usuario ordenó.
Notará que el software en la Figura 1-3 está representado por bloques 
discretos apilados uno encima del otro con bordes fijos. Esto se hace deliberadamente, 
para indicar que existe una separación clara de las diferentes capas funcionales 
de software que conforman el software del sistema embebido completo. 
Mantener estas capas de software en módulos diferentes con interfaces bien definidas para 
que las capas vecinas pueden comunicarse, le ayudará a desarrollar software embebido 
que sea claro, limpio, fácil de leer y portátil.

1.2.2. Requirements That Affect Design Choices

Requerimientos que Afectan a las Decisiones de Diseño

Each embedded system must meet a completely different set of requirements, any or all of which can
affect the compromises and trade-offs made during the development of the product. For example, if the
system must have a production cost of less than $10, other desirable traits—such as processing power
and system reliability—might need to be sacrificed in order to meet that goal.
Of course, production cost is only one of the possible constraints under which embedded hardware
designers work. Other common design requirements include:

Cada sistema embebido debe cumplir un conjunto de requisitos completamente 
diferente, cualquiera de los cuales puede afectar a las decisiones realizadas durante el 
desarrollo del producto. Por ejemplo, si el sistema debe tener un costo de producción menor a 
$ 10, otras caracterísitas usualmente deseables, como el consumo energético o
la confiabilidad del sistema, podrían necesitar ser sacrificadas para alcanzar ese objetivo.
Por supuesto, el costo de producción es solo una de las posibles restricciones 
bajo las cuales trabajan los diseñadores de hardware embebido. Otros requisitos comunes 
de diseño son:

Processing power

Poder de procesamiento (Rendimiento)

The workload that the main chip can handle. A common way to compare processing power is the
millions of instructions per second (MIPS) rating. If two otherwise similar processors have
ratings of 25 MIPS and 40 MIPS, the latter is said to be the more powerful. However, other
important features of the processor need to be considered. One is the register width, which
typically ranges from 8 to 64 bits. Today's general-purpose computers use 32- and 64-bit
processors exclusively, but embedded systems are still mainly built with less costly 4-, 8-, and
16-bit processors.


Es la carga de trabajo que puede computar el chip principal. 
Una forma común de comparar el rendimiento de procesamiento entre dos procesadores 
es la clasificación de millones de instrucciones por segundo (MIPS). En general,
si dos implementaciones de procesadores de la misma arquitectura tienen calificaciones 
de 25 MIPS y 40 MIPS respectivamente, se dice que este último es más potente. 
Sin embargo, deben considerarse otras características importantes del procesador. 
Uno es el ancho del camino de datos en la CPU, que varía de 8 a 64 bits. 
Las PC y laptos de hoy en día son de 64 bits (con algunas aún de 32 bits) 
mientras que en la construcción de sistemas embebidos
se utilizan tambien procesadores menos potentes de 8 y 16 bits.
Procesadores de arquitecturas diferentes son díficiles de comparar. Para
realizar una comparación se pueden realizar benchmarks, y medir el tiempo
de ejecución de varios programas. En estas pruebas los programas
fuentes a utilizar para medir el tiempo de ejecución en cada máquina
tienen que ser los mismos. Tambien el ambiente en donde se ejecutan,
si existe software de soporte a más bajo nivel. Por ejemplo, si existe
Linux en los sistemas a comparar, lo mas indicado es utilizar
exactamente la misma versión de la distribución Linux en cada
sistema (si son de diferentes arquitecturas la distribución Linux
debe proveer los paqutes para las diferentes arquitecturas con la misma versión;
si esto no es posible entonces no se debe utilizar esa distribución Linux).
Además ambos sistemas deben tener exactamente la misma instalación y 
configuración (los mismos paquetes en cada sistema).


Memory

The amount of memory (ROM and RAM) required to hold the executable software and the data
it manipulates. Here the hardware designer must usually make his best estimate up front and be
prepared to increase or decrease the actual amount as the software is being developed. The
amount of memory required can also affect the processor selection. In general, the register width
of a processor establishes the upper limit of the amount of memory it can access (e.g., a 16-bit
address register can address only 64 KB (2 16 ) memory locations). [*]

Memoria 

La cantidad de memoria (ROM y RAM) que se necesita para almacenar
y ejecutar el software del sistema embebido. Aquí, el diseñador de 
hardware generalmente debe realizar los cálculos necesarios para
estimar de la mejor manera posible por adelantado, y estar preparado para 
aumentar o disminuir la cantidad real a medida que se desarrolla el software. 
La cantidad de memoria requerida también puede afectar la selección del 
procesador. En general, el ancho del camino de datos y de los buses de un procesador 
establecen el límite superior de la cantidad de memoria a la que se puede 
acceder (por ejemplo, un registro de dirección de 16 bits puede abordar solo 
64 KB (2 16) ubicaciones de memoria). [*]


[*]
The narrower the register width, the more likely it is that the processor employs tricks such as
multiple address spaces to support more memory. There are still embedded systems that do the
job with a few hundred bytes. However, several thousand bytes is a more likely minimum, even
on an 8-bit processor.


Algunos procesadores deben implementar indirecciones u otros trucos
para acceder a más memoria si el ancho del bus es muy estrecho.
Cuanto más estrecho sea el ancho del bus más probable es que el procesador 
emplee trucos como múltiples espacios de direcciones (o segmentos).
Algunos sistemas embebidos pueden realizar su trabajo
con unos pocos bytes; sin embargo varios miles de bytes es un requisito de
memoria mínimo más común, incluso en un procesador de 8 bits.

Number of units

The expected production run. The trade-off between production cost and development cost is
affected most by the number of units expected to be produced and sold. For example, it rarely
makes sense to develop custom hardware components for a low-volume product.

Cantidad de unidades

Es la cantidad esperada de unidades a fabricar. 
La inversión destinada al desarrollo y producción se verá afectada 
por la cantidad de unidades que se espera fabricar y vender.
Por ejemplo, rara vez tiene sentido desarrollar componentes de 
hardware especializados para un sistema que tendrá un bajo volumen de producción.


Power consumption

The amount of power used during operation. This is extremely important, especially for battery-
powered portable devices. A common metric used to compare the power requirements of
portable devices is mW/MIPS (milliwatts per MIPS); the greater this value, the more power is
required to get work done. Lower power consumption can also lead to other favorable device
characteristics, such as less heat, smaller batteries, less weight, smaller size, and simpler
mechanical design.

El consumo de energía

La cantidad de energía utilizada durante la operación. 
Este requerimiento de diseño suele ser extremadamente importante, 
especialmente en dispositivos portátiles alimentados por un batería. 
Una métrica comunmente utilizada es mW / MIPS (milivatios por MIPS); 
cuanto mayor es este valor se necesitará más potencia para realizar el trabajo. 
Un menor consumo de energía también favorece, usualmente,
al sistema en general (tanto en su diseño como fabricación posterior). Esto
se debe a que el dispositivo generará menos calor, sus
baterías serán más pequeñas, tendrá un peso final menor, 
será mas compacto, y el diseño mecánico será más sencillo.

Development cost

The cost of the hardware and software design processes, known as nonrecurring engineering
(NRE). This is a fixed, one-time cost, so on some projects, money is no object (usually for high-
volume products), whereas on other projects, this is the only accurate measure of system cost
(for the production of a small number of units).

El costo de desarrollo

El costo del proceso de diseńo del software y del hardware, conocido como nonrecurring engineering
(NRE). Es una inversión de única vez, y generalmente fija. El presupuesto para
esta inversión tiene directa relación con la producción final. Si el volumen de productos
será muy grande, el NRE puede tener un presupuesto alto. En cambio, para una producción
de bajo volumen puede haber un presupuesto acotado.

Lifetime

How long the product is expected to stay in use. The required or expected lifetime affects all
sorts of design decisions, from the selection of hardware components to how much system
development and production is allowed to cost. How long must the system continue to function
(on average)? A month, a year, or a decade?

Tiempo de vida

El tiempo esperado de uso del producto. El tiempo de vida requerido o esperado
afecta a todas las decisiones de diseńo, desde la selección de los componentes
de hardware a cuánto es posible invertir en el desarrollo del sistema y su 
producción. La pregunta a responder es : Cuánto tiempo (en promedio) el sistema
debe funcionar? Un mes? Un ańo? Una década?


Reliability

How reliable the final product must be. If it is a children's toy, it may not have to work properly
100 percent of the time, but if it's an antilock braking system for a car, it had sure better do what
it is supposed to do each and every time.
In addition to these general requirements, each system has detailed functional requirements. These are
the things that give the embedded system its unique identity as a microwave oven, pacemaker, or pager.
Table 1-1 illustrates the range of typical values for each of the previous design requirements. The "low,"
"medium," and "high" labels are meant for illustration purposes and should not be taken as strict
deliniations. An actual product has one selection from each row. In some cases, two or more of the
criteria are linked. For example, increases in required processing power could lead to increased
production costs. Conversely, we might imagine that the same increase in processing power would have
the effect of decreasing the development costs—by reducing the complexity of the hardware and
software design. So the values in a particular column do not necessarily go together.

Confiabilidad

Este requerimiento indicará cuán confiable debe ser el producto final. 
Si es un juguete para chicos es posible que no tenga que funcionar correctamente el 100 por 
ciento del tiempo, pero tal vez debe ser seguro (partes pequeñas sueltas podrían ser ingeridas por 
un niño menor a 3 años). En cambio, si se trata de un sistema antibloqueo 
de frenos para un automóvil, es necesario que funcione todas las veces
que se necesite, y que lo haga como se requiere.
Además de estos requisitos generales, cada sistema tiene requisitos funcionales 
detallados específicos; que le dan al sistema embebido su identidad única (horno de microondas, marcapasos o consola de juegos).

La Tabla 1-1 ilustra el rango de valores típicos para cada uno de los requisitos de diseño anteriores. 

Las etiquetas "bajo", "medio" y "alto" tienen fines ilustrativos y no deben tomarse como límites estrictos. 
Un producto real tiene una selección de cada fila. En algunos casos, dos o más de los criterios 
podrían estar vinculados. Por ejemplo, un aumento en la potencia de procesamiento 
requerida podrían generar mayores costos de producción. 
Por el contrario, podríamos pensar que el mismo aumento en la potencia de 
procesamiento tendrá el efecto de disminuir los costos de desarrollo, 
al reducir la complejidad del diseño de hardware y software. 
Por lo tanto, los valores en una columna en particular no necesariamente van juntos.





Table 1-1. Common design requirements for embedded systems
Criterion
Low
Medium
High
Processor 4- or 8-bit 16-bit 32- or 64-bit
Memory < 64 KB 64 KB to 1 MB > 1 MB
Development cost < $100,000 $100,000 to $1,000,000 > $1,000,000
Production cost < $10 $10 to $1,000 > $1,000
Number of units < 100 100 to 10,000 > 10,000
Power consumption > 10 mW/MIPS 1 to 10 mW/MIPS < 1 mW/MIPS
Lifetime Days, weeks, or months Years Decades

Reliability May occasionally fail Must work reliably Must be fail-proof




1.3. Embedded Design Examples

To demonstrate the variation in design requirements from one embedded system to the next, as well as
the possible effects of these requirements on the hardware, we will now take some time to describe three
embedded systems in some detail. Our goal is to put you in the system designer's shoes for a few
moments before narrowing our discussion to embedded software development.

1.3.1. Digital Watch

At the current peak of the evolutionary path that began with sundials, water clocks, and hourglasses is
the digital watch. Among its many features are the presentation of the date and time (usually to the
nearest second), the measurement of the length of an event to the nearest hundredth of a second, and the
generation of an annoying little sound at the beginning of each hour. As it turns out, these are very
Page 16Programming Embedded Systems Second Edition
simple tasks that do not require very much processing power or memory. In fact, the only reason to
employ a processor at all is to support a range of models and features from a single hardware design.
The typical digital watch contains a simple, inexpensive 4-bit processor. Because processors with such
small registers cannot address very much memory, this type of processor usually contains its own on-
chip ROM. And, if there are sufficient registers available, this application may not require any RAM at
all. In fact, all of the electronics— processor, memory, counters, and real-time clocks—are likely to be
stored in a single chip. The only other hardware elements of the watch are the inputs (buttons) and
outputs (display and speaker).

A digital watch designer's goal is to create a reasonably reliable product that has an extraordinarily low
production cost. If, after production, some watches are found to keep more reliable time than most, they
can be sold under a brand name with a higher markup. For the rest, a profit can still be made by selling
the watch through a discount sales channel. For lower-cost versions, the stopwatch buttons or speaker
could be eliminated. This would limit the functionality of the watch but might require few or even no
software changes. And, of course, the cost of all this development effort may be fairly high, because it
will be amortized over hundreds of thousands or even millions of watch sales.
In the case of the digital watch, we see that software, especially when carefully designed, allows
enormous flexibility in response to a rapidly changing and highly competitive market.

1.3.1. Reloj digital

En la cima actual del camino evolutivo que comenzó con relojes de sol, relojes de agua y relojes de arena está el reloj digital.
Entre sus muchas características están la presentación de la fecha y la hora 
(generalmente al segundo más cercano), la medición de la duración de un evento a la centésima de 
segundo más cercana y la generación de un pequeño sonido molesto al comienzo de cada hora. 
Como resultado, estas son tareas muy simples que no requieren mucha potencia de procesamiento o memoria. 
De hecho, la única razón para emplear un procesador es admitir una gama de modelos y 
características desde un solo diseño de hardware.
El reloj digital típico contiene un procesador de 8 bits simple y económico. Debido a que estos procesadores 
no pueden direccionar mucha memoria, contiene su propia pequeña ROM en el chip. 
Y, si hay suficientes registros disponibles, es posible que esta aplicación 
no requiera RAM en absoluto. De hecho, es probable que todos los componentes 
electrónicos (procesador, memoria, contadores y relojes en tiempo real) sea el único hardware
disponible en el chip.
Los otros elementos de hardware del reloj son las entradas (botones) y las salidas (pantalla y altavoz).

El objetivo de un diseñador de relojes digitales es crear un producto razonablemente 
confiable, y que tenga un costo de producción extraordinariamente bajo. 
Si, después de la producción, se descubre que algunos relojes mantienen un 
tiempo más confiable que los demás, se pueden vender bajo una marca mas cara.
Por lo demás, aún se pueden obtener ganancias vendiendo el reloj a través 
de un canal de venta con descuento. Para las versiones de menor costo, 
los botones del cronómetro o el altavoz podrían eliminarse. 
Esto limitaría la funcionalidad del reloj, pero podría requerir pocos o incluso 
ningún cambio de software. Y, por supuesto, el costo de todo este esfuerzo de 
desarrollo puede ser bastante alto, ya que se amortizará en cientos de miles o 
incluso millones de ventas de relojes.
En el caso del reloj digital, vemos que el software, especialmente cuando está 
cuidadosamente diseñado, permite una enorme flexibilidad en respuesta a un mercado 
rápidamente cambiante y altamente competitivo.

Un tipo de reloj mas actual es el reloj digital inteligente. Este reloj es totalmente
diferente al anterior y puede costar mil veces más. 
Los relojes inteligentes tienen usualmente un microprocesador de 32 bits (arquitectura ARM),
mucha cantidad de RAM para estos dispositivos (por ej. 512MB) y varios
GB de disco. Cuentan con conexion wireless y su software se comunica
con un teléfono inteligente, del cual obtiene mensajes y avisos para comunicar
al usuario a través de una pantalla LCD en el reloj.
En este tipo de relojes el presupuesto de desarrollo es mucho mayor,
porque ya la categoría del hardware a controlar y del software 
a desarrollar es extremadamente compleja.

1.3.2. Video Game Player

When you pull the Sony PlayStation 2 out from your entertainment center, you are preparing to use an
embedded system. In some cases, these machines are more powerful than personal computers of the
same generation. Yet video game players for the home market are relatively inexpensive compared with
personal computers. It is the competing requirements of high processing power and low production cost
that keep video game designers awake at night.

The companies that produce video game players don't usually care how much it costs to develop the
system as long as the production costs of the resulting product are low—typically around a hundred
dollars. They might even encourage their engineers to design custom processors at a development cost
of millions of dollars each. So, although there might be a 64-bit processor inside your video game
player, it is probably not the same processor that would be found in a general-purpose computer. In all
likelihood, the processor is highly specialized for the demands of the video games it is intended to play.
Because production cost is so crucial in the home video game market, the designers also use tricks to
shift the costs around. For example, one tactic is to move as much of the memory and other peripheral
electronics as possible off of the main circuit board and onto the game cartridges. [ ] This helps to
reduce the cost of the game player but increases the price of every game. So, while the system might
have a powerful 64-bit processor, it might have only a few megabytes of memory on the main circuit
board. This is just enough memory to bootstrap the machine to a state from which it can access
additional memory on the game cartridge.
[ ]

For example, Atari and Nintendo have designed some of their systems this way.

We can see from the case of the video game player that in high-volume products, a lot of development
effort can be sunk into fine-tuning every aspect of a product.



Consola de Video Juegos

Cuando conectes tu Sony PlayStation 4 a tu smart TV te estás preparando para utilizar decenas de sistemas embebidos.
Las consolas de video juegos pueden llegar a ser más potentes que las PC
de su misma generación; aún si las consolas son relativamente mas baratas que las PC.
Esto se debe a que existe un requisito competitivo de alto poder de cómputo
a un costo bajo de producción. Tales requisitos obligan a los 
diseñadores de las consolas de videojuegos a estar despiertos por las noches.

A las compañías que producen consolas de videojuegos generalmente no les importa 
cuánto cuesta desarrollar el sistema, siempre que los costos de producción del 
producto resultante sean bajos.
Incluso podrían ofrecer la posibilidad, a sus ingenieros, de diseñar un procesador personalizado 
a un costo de desarrollo de millones de dólares cada uno. 
Entonces, aunque puede haber un procesador de 64 bits dentro de la consola 
probablemente no sea el mismo procesador que se encontraría en una 
computadora personal. Con toda probabilidad, el procesador está altamente especializado 
para las demandas de los videojuegos que está destinado a ejecutar.

Debido a que el costo de producción es tan crucial en el mercado de videojuegos 
se deben tambien realizar ciertos tricks para modificar esos costos. Por ejemplo, los
diseñadores han utilizado la táctica de mover la mayor cantidad de memoria 
y otros dispositivos electrónicos fuera de la 
placa de circuito impreso principal, y han colocado este hardware en los cartuchos de juego. [] 
Esto ayuda a reducir el costo de la consola pero aumenta el precio de cada juego. 
Entonces, si bien el sistema podría tener un procesador potente de 64 bits, 
podría tener solo unos pocos megabytes de memoria en la placa de circuito principal. 
Con esta poca memoria ya es suficiente para iniciar 
la máquina a un estado desde el cual se puede acceder a la memoria adicional 
contenida en el cartucho del juego.

Por ejemplo, Atari y Nintendo han diseñado algunos de sus sistemas de esta manera.

Podemos ver, en este ejemplo, que en productos de gran masividad se puede dedicar 
mucho esfuerzo de desarrollo a ajustar cada aspecto del sistema.



1.3.3. Mars Rover

In 1976, two unmanned spacecrafts arrived on the planet Mars. As part of their mission, they were to
collect samples of the Martian surface, analyze the chemical makeup of each, and transmit the results to
scientists back on Earth. Those Viking missions were amazing. Surrounded by personal computers that
must be rebooted occasionally, we might find it remarkable that more than 30 years ago, a team of
scientists and engineers successfully built two computers that survived a journey of 34 million miles and
functioned correctly for half a decade. Clearly, reliability was one of the most important requirements
for these systems.

What if a memory chip had failed? Or the software had contained bugs that had caused it to crash? Or an
electrical connection had broken during impact? There is no way to prevent such problems from
occurring, and on other space missions, these problems have proved ruinous. So, all of these potential
failure points and many others had to be eliminated by adding redundant circuitry or extra functionality:
an extra processor here, special memory diagnostics there, a hardware timer to reset the system if the
software got stuck, and so on.

More recently, NASA launched the Pathfinder mission. Its primary goal was to demonstrate the
feasibility of getting to Mars on a budget. Of course, given the advances in technology made since the
mid-70s, the designers didn't have to give up too much to accomplish this. They might have reduced the
amount of redundancy somewhat, but they still gave Pathfinder more processing power and memory
than Viking. The Mars Pathfinder was actually two embedded systems: a landing craft and a rover. The
landing craft had a 32-bit processor and 128 MB of RAM; the rover, on the other hand, had only an 8-bit
processor and 512 KB of RAM. These choices reflect the different functional requirements of the two
systems. Production cost probably wasn't much of an issue in either case; any investment would have
been worth an improved likelihood of success.

1.3.3. Mars Rover

En 1976, dos naves espaciales no tripuladas llegaron al planeta Marte. 
Como parte de su misión, debían recolectar muestras de la superficie marciana, 
analizar la composición química de cada una y transmitir los resultados a los 
científicos en la Tierra. Esas misiones Vikingas fueron impresionantes. 
Siendo que uno está rodeado de computadoras personales que deben reiniciarse 
ocasionalmente, podríamos encontrar casi increíble que hace más de 30 años, 
un equipo de científicos e ingenieros construyeron con éxito dos computadoras 
que sobrevivieron a un viaje de 34 millones de millas y funcionaron 
correctamente durante media década. 
Claramente, la confiabilidad era uno de los requisitos más importantes para estos sistemas.

¿Qué pasa si un chip de memoria falla? ¿O si el software contenía errores y se bloqueaba? 
¿O si se hubiese roto una conexión eléctrica durante el impacto? 
No hay forma de evitar que ocurran tales problemas, y en otras misiones espaciales, 
estos problemas han resultado ser desastrosos. 
Entonces, todos estos puntos potenciales de falla y muchos otros 
tuvieron que ser eliminados agregando circuitos redundantes o 
funcionalidades adicionales:
un procesador adicional aquí, diagnósticos especiales de memoria por allá, 
un temporizador de hardware para reiniciar el sistema si el software se 
bloquea, y así sucesivamente.

Más recientemente, la NASA lanzó la misión Pathfinder. Su objetivo principal era 
demostrar la viabilidad de llegar a Marte con un cierto presupuesto. 
Por supuesto, dados los avances tecnológicos realizados desde mediados de 
los años 70, los diseñadores no tuvieron que quitar muchas caracterísitas del sistema (como uno esperaría)
para lograr esto. Es posible que hayan reducido un poco la cantidad de 
redundancia, pero aún así le dieron a Pathfinder más poder de procesamiento y memoria
que al anciano Vikingo. El Mars Pathfinder estaba compuesto en realidad 
por dos sistemas embebidos: una nave de aterrizaje y un rover. 
La nave de aterrizaje tenía un procesador de 32 bits y 128 MB de RAM; 
el rover, por otro lado, solo tenía un procesador de 8 bits y 512 KB de RAM. 
Estas elecciones reflejan los diferentes requisitos funcionales de los dos 
sistemas. El costo de producción probablemente no fue un gran problema en 
ninguno de los casos.

1.4. Life As an Embedded Software Developer

Let's now take a brief look at some of the qualities of embedded software that set embedded developers
apart from other types of software developers. An embedded software developer is the one who gets her
hands dirty by getting down close to the hardware.

Embedded software development, in most cases, requires close interaction with the physical world—the
hardware platform. We say "in most cases" because there are very large embedded systems that require
individuals to work solely on the application-layer software for the system. These application developers
typically do not have any interaction with the hardware. When designed properly, the hardware device
drivers are abstracted away from the actual hardware so that a developer writing software at the
application level doesn't know how a string gets output to the display, just that it happens when a
particular routine is called with the proper parameters.

1.4. La vida de un desarrollador de software embebido

Veamos ahora brevemente algunas de las cualidades del software embebido, 
que diferencian a los desarrolladores embebidos de otros tipos de desarrolladores de software. 
Un desarrollador de software embebido es aqué que se ensucia las manos acercándose al hardware.

El desarrollo de software embebidos, en la mayoría de los casos, requiere una estrecha interacción 
con el mundo físico: la plataforma de hardware. Decimos "en la mayoría de los casos" 
porque hay sistemas embebidos muy grandes que requieren que las personas trabajen 
únicamente en el software de la capa de aplicación para el sistema. 
Estos desarrolladores de aplicaciones generalmente no tienen ninguna 
interacción con el hardware. Cuando se diseñan correctamente, los controladores 
del dispositivo de hardware se abstraen del hardware real para que un 
desarrollador que escribe el software a nivel de aplicación no sepa cómo se 
genera una cadena en la pantalla, solo que sucede cuando se llama a una 
rutina particular con los parámetros adecuados.


Hardware knowledge

The embedded software developer must become intimately familiar with the integrated circuits,
the boards and buses, and the attached devices used in order to write solid embedded software
(also called firmware). Embedded developers shouldn't be afraid to dive into the schematics,
grab an oscilloscope probe, and start poking around the circuit to find out what is going on.

Conocimiento del hardware

El desarrollador de software embebidos debe familiarizarse íntimamente con los 
circuitos integrados, las placas de circuito impreso, los buses, y los dispositivos 
que se utilizan para transferir y testear el software embebido sólido (también denominado firmware). 
No se debe sentir temor por los esquemáticos, o tomar una sonda del osciloscopio y 
comenzar a hurgar en el circuito para descubrir qué está sucediendo.

Efficient code

Because embedded systems are typically designed with the least powerful and most cost-
effective processor that meets the performance requirements of the system, embedded software
developers must make every line of code count. The ability to write efficient code is a great
quality to possess as a firmware developer.

Código eficiente

Los desarrolladores de software embebido deben tener en cuenta
cada línea de código fuente, ya que los sistemas embebidos 
generalmente están diseñados con el procesador menos potente posible
(pero que cumple con los requisitos de rendimiento del sistema). 
La capacidad de escribir código eficiente es una gran cualidad
que deben poseer los desarrolladores de firmware.


Peripheral interfaces

At the lowest level, firmware is very specialized, because each component or circuit has its own
activity to perform and, furthermore, its own way of performing that activity. Embedded
developers need to know how to communicate with the different devices or peripherals in order
to have full control of the devices in the system. Reacting to stimuli from external peripherals is
a large part of embedded software development.

For example, in one microwave oven, the firmware might get the data from a temperature sensor
by reading an 8-bit register in an external analog-to-digital converter; in another system, the data
might be extracted by controlling a serial bus that interfaces to the external sensor circuit via a
single wire.

Interfaces a los dispositivos

A bajo nivel el firmware es muy especializado, porque cada componente o circuito 
tiene su propia actividad que realizar y, además, su propia forma de realizar esa actividad. 
Los desarrolladores embebidos necesitan saber cómo comunicarse con 
los diferentes dispositivos o periféricos, para tener un control total de los mismos dentro
del sistema. Saber como atender eventos provenientes de periféricos externos es una gran 
parte del desarrollo de software embebido.

Por ejemplo, en un horno microondas, el firmware puede obtener los datos 
del sensor de temperatura leyendo un registro de 8 bits de un 
conversor externo analógico a digital. En otro sistema, los datos 
podrían provenir controlando un bus serie que se conecta al 
circuito del sensor externo a través de un único cable.
Dos maneras distinas en hardware y software en dos sistemas distintos
para una misma funcionalidad de entrada.


Robust code

There are expectations that embedded systems will run for years in most cases. This is not a
typical requirement for software applications written for a PC or Mac. Now, there are exceptions.
However, if you had to keep unplugging your microwave in order to get it to heat up your lunch
for the proper amount of time, it would probably be the last time you purchased a product from
that company.

Código robusto

En muchos casos se espera que el sistema embebido funcione durante años.
Este no es un requisito típico para las aplicaciones desarrolladas para PC, Mac o el smartphone (aunque hay excepciones).
Por lo tanto, si luego de un tiempo la única manera de finalizar la
coción en su horno microcondas es abriendo la puerta (porque el sistema de reloj ya no funciona
o lo que fuese la causa) entonces es muy probable
que ya no vuelva a comprar un producto de esa marca.



Minimal resources

Along the same lines of creating a more robust system, another large differentiator between
embedded software and other types of software is resource constraints. The rules for writing
firmware are different from the rules for writing software for a PC. Take memory allocation, for
instance. An application for a modern PC can take for granted that it will have access to
practically limitless resources. But in an embedded system, you will run out of memory if you do
not plan ahead and design the software properly.
An embedded software developer must closely manage resources, from memory to processing
power, so that the system operates up to specification and so failures don't occur. For example,
using standard dynamic memory allocation functions can cause fragmentation, and eventually
the system may cease to operate. This requires a reboot since you have no place to store
incoming data.

Quite often, in embedded software, a developer will allocate all memory needed by the system at
initialization time. This is safer than using dynamic memory allocation, though it cannot always
be done.

Recursos mínimos

En la misma línea de crear un sistema más robusto, otro gran diferenciador entre el software incorporado y otros tipos de software son las limitaciones de recursos. Las reglas para escribir firmware son diferentes de las reglas para escribir software para una PC. Tome la asignación de memoria, por ejemplo. Una aplicación para una PC moderna puede dar por sentado que tendrá acceso a recursos prácticamente ilimitados. Pero en un sistema embebido, se quedará sin memoria si no planifica con anticipación y diseña el software correctamente.
Un desarrollador de software integrado debe administrar de cerca los recursos, desde la memoria hasta la potencia de procesamiento, para que el sistema funcione según las especificaciones y no se produzcan fallas. Por ejemplo, el uso de funciones de asignación de memoria dinámica estándar puede causar fragmentación y, finalmente, el sistema puede dejar de funcionar. Esto requiere un reinicio ya que no tiene lugar para almacenar datos entrantes.

Muy a menudo, en el software integrado, un desarrollador asignará toda la memoria que necesita el sistema en el momento de la inicialización. Esto es más seguro que usar la asignación dinámica de memoria, aunque no siempre se puede hacer.



Reusable software

As we mentioned before , code portability or code reuse—writing software so that it can be
moved from hardware platform to hardware platform—is very useful to aid transition to new
projects. This cannot always be done; we have seen how individual each embedded system is.
Throughout this book, we will look at basic methods to ensure that your embedded code can be
moved more easily from project to project. So if your next project uses an LCD for which you've
previously developed a driver, you can drop in the old code and save some precious time in the
schedule.

Software reutilizable

Como mencionamos anteriormente, la portabilidad del código o la reutilización del código —escribiendo software para que se pueda mover de la plataforma de hardware a la plataforma de hardware— es muy útil para ayudar a la transición a nuevos proyectos. Esto no siempre se puede hacer; Hemos visto cuán individual es cada sistema embebido. A lo largo de este libro, analizaremos métodos básicos para garantizar que su código incrustado se pueda mover más fácilmente de un proyecto a otro. Por lo tanto, si su próximo proyecto utiliza una pantalla LCD para la cual ha desarrollado previamente un controlador, puede colocar el código anterior y ahorrar un tiempo precioso en el cronograma.

Development tools

The tools you will use throughout your career as an embedded developer will vary from
company to company and often from project to project. This means you will need to learn new
tools as you continue in your career. Typically, these tools are not as powerful or as easy to use
as those used in PC software development.

The debugging tools you might come across could vary from a simple LED to a full-blown in-
circuit emulator (ICE). This requires you, as the firmware developer, and the one responsible for
debugging your code, to be very resourceful and have a bag of techniques you can call upon
when the debug environment is lacking. Throughout the book, we will present different "low-
level software tools" you can implement with little impact on the hardware design.
Page 20Programming Embedded Systems Second Edition
These are just a few qualities that separate embedded software developers from the rest of the pack. We
will investigate these and other techniques that are specific to embedded software development as we
continue.

1.5. The C Language: The Lowest Common Denominator

One of the few constants across most embedded systems is the use of the C programming language.
More than any other, C has become the language of embedded programmers. This has not always been
the case, and it will not continue to be so forever. However, at this time, C is the closest thing there is to
a standard in the embedded world. In this section, we'll explain why C has become so popular and why
we have chosen it as the primary language of this book.
Because successful software development so frequently depends on selecting the best language for a
given project, it is surprising to find that one language has proven itself appropriate for both 8-bit and
64-bit processors; in systems with bytes, kilobytes, and megabytes of memory; and for development
teams that range from one to a dozen or more people. Yet this is precisely the range of projects in which
C has thrived.

The C programming language has plenty of advantages. It is small and fairly simple to learn, compilers
are available for almost every processor in use today, and there is a very large body of experienced C
programmers. In addition, C has the benefit of processor-independence, which allows programmers to
concentrate on algorithms and applications rather than on the details of a particular processor
architecture. However, many of these advantages apply equally to other high-level languages. So why
has C succeeded where so many other languages have largely failed?
Perhaps the greatest strength of C—and the thing that sets it apart from languages such as Pascal and
FORTRAN—is that it is a very "low-level" high-level language. As we shall see throughout the book, C
gives embedded programmers an extraordinary degree of direct hardware control without sacrificing the
benefits of high-level languages. The "low-level" nature of C was a clear intention of the language's
creators. In fact, Brian W. Kernighan and Dennis M. Ritchie included the following comment in the
opening pages of their book The C Programming Language (Prentice Hall):
C is a relatively "low level" language. This characterization is not pejorative; it simply means that C
deals with the same sort of objects that most computers do. These may be combined and moved about
with the arithmetic and logical operators implemented by real machines.
Few popular high-level languages can compete with C in the production of compact, efficient code for
almost all processors. And, of these, only C allows programmers to interact with the underlying
hardware so easily.

1.5.1. Other Embedded Languages

Of course, C is not the only language used by embedded programmers. At least four other languages—
assembly, C++, Forth, and Ada—are worth mentioning in greater detail.

In the early days, embedded software was written exclusively in the assembly language of the target
processor. This gave programmers complete control of the processor and other hardware, but at a price.
Assembly languages have many disadvantages, not the least of which are higher software development
costs and a lack of code portability. In addition, finding skilled assembly programmers has become
much more difficult in recent years. Assembly is now used primarily as an adjunct to the high-level
language, usually only for startup system code or those small pieces of code that must be extremely
efficient or ultra-compact, or cannot be written in any other way.
Forth is efficient but extremely low-level and unusual; learning to get work done with it takes more time
than with C.

C++ is an object-oriented superset of C that is increasingly popular among embedded programmers. All
of the core language features are the same as C, but C++ adds new functionality for better data
abstraction and a more object-oriented style of programming. These new features are very helpful to
software developers, but some of them reduce the efficiency of the executable program. So C++ tends to
be most popular with large development teams, where the benefits to developers outweigh the loss of
program efficiency.

Ada is also an object-oriented language, though substantially different from C++. Ada was originally
designed by the U.S. Department of Defense for the development of mission-critical military software.
Despite being twice accepted as an international standard (Ada83 and Ada95), it has not gained much of
a foothold outside of the defense and aerospace industries. And it has been losing ground there in recent
years. This is unfortunate because the Ada language has many features that would simplify embedded
software development if used instead of C or C++.

1.5.1. Otros lenguajes de programación para sistemas embebidos

C no es el único lenguaje utilizado. Vale la pena mencionar con 
más detalle al menos otros lenguajes: ensamblador, C ++, Forth, Ada, Lua y Python (o microPython).

Antiguamente el software embebido se escribía exclusivamente utilizando lenguaje ensamblador.
Era la única manera de tener el control completo del procesador y del hardware restante, pero a un precio.
Los lenguajes ensambladores son dependientes de la arquitectura por lo que presentan muchas desventajas. 
Una desventaja es que el costo de desarrollo es muy elevado (el código fuente es muy 
dificil de leer y mantener), y el software no es portable. 
Además, encontrar programadores que conozcan lenguaje ensamblador es bastante dificil hoy en día.
El lenguaje ensamblador se utiliza principalmente como un complemento a los lenguajes de
alto nivel. Se utiliza para escribir una porción del código de arranque de un sistema,
o en pequeños fragmentos de código que deben ser extremadamente eficientes o ultracompactos.
Forth es eficiente pero es de un nivel extremadamente bajo e inusual; aprender a trabajar 
con Forth lleva más tiempo que con C.

C++ es un superconjunto de C orientado a objetos que es cada vez más popular entre los programadores embebidos. 
Todas las características principales del lenguaje son las mismas que C, y como un extra
C++ es mas adecuado para estructuras de datos complejas y abstractas (es orientado a objetos).
Estas características son muy útiles para los desarrolladores de software, pero 
algunas de ellas reducen la eficiencia del programa ejecutable. 
Por lo tanto, C ++ tiende a ser más popular entre los grandes equipos de 
desarrollo, donde los beneficios para los desarrolladores superan la posible
pérdida de eficiencia que pudiera tener el programa final.

Ada también es un lenguaje orientado a objetos, aunque sustancialmente diferente de C++. 
Ada fue diseñada originalmente por el Departamento de Defensa de los EE. UU. para 
el desarrollo de software militar de misión crítica.  
A pesar de ser dos veces aceptado como un estándar internacional (Ada83 y Ada95), 
no ha ganado mucho apoyo fuera de las industrias de defensa y aeroespaciales. 
E incluso ha estado perdiendo mercado allí mismo en los últimos años. 
Esto es lamentable porque el lenguaje Ada tiene muchas características 
que simplificarían el desarrollo de software embebido si se usa en lugar de C o C++.
